use std::path::PathBuf;
use std::{env, fs};

use anyhow::{Context, Result};
use clap::Args;
use serde::de::DeserializeOwned;

use crate::dirs;

#[derive(Debug, Args)]
pub struct ConfigArgs {
    /// Configuration directory path, all configuration files will be read from this path.
    /// The directory will be automatically created if it does not exist. Note that certain
    /// behaviors of csync will generate specific files in this directory (if you have not
    /// provided them)
    #[arg(long)]
    pub config_path: Option<String>,

    /// Data directory path. Persistent data generated by the process will be stored in this
    /// directory. The directory will be automatically created if it does not exist
    #[arg(long)]
    pub data_path: Option<String>,
}

#[derive(Debug, Clone)]
pub struct PathSet {
    pub config_dir: PathBuf,
    pub data_dir: PathBuf,
    pub tmp_dir: PathBuf,
}

pub trait CommonConfig: Default {
    fn complete(&mut self, _ps: &PathSet) -> Result<()> {
        Ok(())
    }
}

impl ConfigArgs {
    const CONFIG_DIR_ENV: &str = "CSYNC_CONFIG_PATH";
    const DATA_DIR_ENV: &str = "CSYNC_DATA_PATH";

    pub fn build_path_set(&self) -> Result<PathSet> {
        let config_dir = match self.config_path {
            Some(ref path) => PathBuf::from(path),
            None => match env::var(Self::CONFIG_DIR_ENV) {
                Ok(path) => PathBuf::from(path),
                Err(_) => dirs::config_dir()?,
            },
        };
        dirs::ensure_dir_exists(&config_dir)?;

        let data_dir = match self.data_path {
            Some(ref path) => PathBuf::from(path),
            None => match env::var(Self::DATA_DIR_ENV) {
                Ok(path) => PathBuf::from(path),
                Err(_) => dirs::data_dir()?,
            },
        };
        dirs::ensure_dir_exists(&data_dir)?;

        let tmp_dir = data_dir.join("tmp");
        dirs::ensure_dir_exists(&tmp_dir)?;

        Ok(PathSet {
            config_dir,
            data_dir,
            tmp_dir,
        })
    }

    pub fn load<C>(&self, name: &str) -> Result<C>
    where
        C: CommonConfig + DeserializeOwned,
    {
        let ps = self.build_path_set()?;
        self.load_from_path_set(name, &ps)
    }

    pub fn load_from_path_set<C>(&self, name: &str, ps: &PathSet) -> Result<C>
    where
        C: CommonConfig + DeserializeOwned,
    {
        let path = ps.config_dir.join(format!("{name}.toml"));

        let mut cfg = if path.try_exists().context("check config file exists")? {
            let data = fs::read_to_string(&path)?;
            toml::from_str(&data).context("parse config file")?
        } else {
            C::default()
        };

        cfg.complete(ps).context("check config")?;

        Ok(cfg)
    }
}
