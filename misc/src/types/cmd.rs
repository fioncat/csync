use std::path::PathBuf;

use anyhow::Result;
use clap::Args;

use crate::config::PathSet;
use crate::logs;

#[derive(Args, Debug, Clone)]
pub struct ConfigArgs {
    /// Configuration directory path, all configuration files will be read from this path.
    /// The directory will be automatically created if it does not exist. Note that certain
    /// behaviors of csync will generate specific files in this directory (if you have not
    /// provided them)
    #[arg(long)]
    pub config_path: Option<String>,

    /// Data directory path. Persistent data generated by the process will be stored in this
    /// directory. The directory will be automatically created if it does not exist
    #[arg(long)]
    pub data_path: Option<String>,
}

#[derive(Args, Debug, Clone)]
pub struct LogArgs {
    /// Log level.
    #[arg(long, default_value = "info")]
    pub log_level: String,
}

impl ConfigArgs {
    pub fn build_path_set(&self) -> Result<PathSet> {
        PathSet::new(
            self.config_path.clone().map(PathBuf::from),
            self.data_path.clone().map(PathBuf::from),
        )
    }
}

impl LogArgs {
    pub fn init(&self) -> Result<()> {
        logs::init(&self.log_level)
    }
}
